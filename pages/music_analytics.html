<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotiviz - Music Analytics</title>
    <link rel="stylesheet" href="../styles.css">
    <!-- Include D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .line {
            fill: none;
            stroke-width: 2;
        }
        .axis-label {
            font-size: 12px;
            font-weight: bold;
        }
        .legend {
            font-size: 12px;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
        }
        .album-trends-container {
            margin-top: 30px;
            display: none; /* Hidden by default, will show when selected */
        }
        .visualization-section {
            margin-bottom: 40px;
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <img src="../data/spotify_image.jpg" alt="Spotify Logo"> Spotiviz
        </div>
        <h1>Music Analytics</h1>
    </header>
     
    <div class="container">
        <nav class="sidebar">
            <button onclick="location.href='../index.html'">Overview</button>
            <button onclick="location.href='music_analytics.html'" class="active">Music Analytics</button>
            <button onclick="location.href='podcast_analytics.html'">Podcast Analytics</button>
            <button onclick="location.href='kpi.html'">Key Performance Indicators</button>
            <button onclick="location.href='settings.html'">Settings</button>
        </nav>
             
        <main class="content music-analytics-content">
            <div class="controls">
                <div class="control-group">
                    <label for="visualization-type">Visualization:</label>
                    <select id="visualization-type">
                        <option value="listening-trends">Listening Trends</option>
                        
                    </select>
                </div>
                <div class="control-group">
                    <label for="artist-select">Artist:</label>
                    <select id="artist-select">
                        <option value="all">All Artists</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="time-range">Time Range:</label>
                    <select id="time-range">
                        <option value="all">All Time</option>
                        <option value="2016">2016</option>
                        <option value="2017">2017</option>
                        <option value="2018">2018</option>
                        <option value="2019">2019</option>
                        <option value="2020">2020</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="metric-select">Metric:</label>
                    <select id="metric-select">
                        <option value="streams">Total Streams</option>
                        <option value="rank">Average Rank</option>
                    </select>
                </div>
                
                <!-- Album trends specific controls (hidden by default) -->
                <div class="control-group album-trends-control">
                    <label for="top-albums">Top Albums:</label>
                    <input type="number" id="top-albums" min="1" max="20" value="5">
                </div>
            </div>
                     
            <!-- Original visualization section -->
            <div id="listening-trends-section" class="visualization-section">
                <div class="visualization-container">
                    <h2 id="visualization-title">Listening Trends Over Time</h2>
                    <div id="chart-container">
                        <svg id="trends-chart"></svg>
                    </div>
                    <div id="top-songs-container">
                        <h3>Top Songs</h3>
                        <ul id="top-songs-list"></ul>
                    </div>
                </div>
            </div>
            
            <!-- Album trends visualization section (initially hidden) -->
            <div id="album-trends-section" class="visualization-section album-trends-container">
                <div class="visualization-container">
                    <h2>Album Weekly Chart Rankings</h2>
                    <div id="album-chart-container"></div>
                </div>
            </div>
                     
            <div id="loading">Loading data...</div>
        </main>
    </div>
     
    <footer>
        @ 2025 Spotify Analytics Dashboard
    </footer>
     
    <!-- Original JavaScript file -->
    <script src="../music_analytics.js"></script>
    
    <!-- Album trends JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Set up visualization type toggle
            const visualizationType = document.getElementById('visualization-type');
            const listeningTrendsSection = document.getElementById('listening-trends-section');
            const albumTrendsSection = document.getElementById('album-trends-section');
            const albumTrendsControls = document.querySelectorAll('.album-trends-control');
            
            visualizationType.addEventListener('change', function() {
                if (this.value === 'album-trends') {
                    listeningTrendsSection.style.display = 'none';
                    albumTrendsSection.style.display = 'block';
                    albumTrendsControls.forEach(control => control.style.display = 'block');
                    // Initialize album chart if not already initialized
                    if (!albumChartInitialized) {
                        initAlbumChart();
                    }
                } else {
                    listeningTrendsSection.style.display = 'block';
                    albumTrendsSection.style.display = 'none';
                    albumTrendsControls.forEach(control => control.style.display = 'none');
                }
            });
            
            // Hide album trends controls by default
            albumTrendsControls.forEach(control => control.style.display = 'none');
            
            // Album Trends Visualization Code
            let albumChartInitialized = false;
            
            function initAlbumChart() {
                // Chart dimensions
                const margin = {top: 50, right: 200, bottom: 70, left: 80};
                const width = 900 - margin.left - margin.right;
                const height = 500 - margin.top - margin.bottom;
                
                // Initialize tooltip
                const tooltip = d3.select("body")
                    .append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);
                    
                // Color scale
                const color = d3.scaleOrdinal(d3.schemeCategory10);
                
                // Create SVG
                const svg = d3.select("#album-chart-container")
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`); 
                // Load data
                d3.json("../data/Merge Data/all_albums.json").then(data => {
                    console.log("Data loaded successfully:", data);
                    // Process data
                    // Invert rank (lower rank number is better)
                    data.forEach(d => {
                        d.rank = +d.rank;  // Make sure rank is a number
                        d.peak = +d.peak;
                        d.previous = +d.previous;
                    });
                    
                    // Get unique weeks
                    const weeks = [...new Set(data.map(d => d.week))].sort();
                    
                    // Get unique artists
                    const artists = [...new Set(data.map(d => d.artist))].sort();
                    
                    // Populate artist dropdown (use the existing one)
                    const artistSelect = d3.select("#artist-select");
                    // Clear existing options first (keeping the 'All Artists' option)
                    artistSelect.selectAll("option:not([value='all'])")
                        .remove();
                        
                    artists.forEach(artist => {
                        artistSelect.append("option")
                            .attr("value", artist)
                            .text(artist);
                    });
                    
                    // Find the top N albums across all weeks
                    function getTopAlbums(filteredData, topN) {
                        // Group by album and calculate average rank
                        const albumGroups = d3.group(filteredData, d => d.album);
                        
                        const albumStats = Array.from(albumGroups, ([album, entries]) => {
                            return {
                                album: album,
                                artist: entries[0].artist,  // assuming same artist per album
                                avgRank: d3.mean(entries, d => d.rank),
                                count: entries.length,  // number of weeks on chart
                                // Add first and last week for each album
                                firstWeek: d3.min(entries, d => d.week),
                                lastWeek: d3.max(entries, d => d.week)
                            };
                        });
                        
                        // Sort by average rank
                        albumStats.sort((a, b) => a.avgRank - b.avgRank);
                        
                        // Return top N
                        return albumStats.slice(0, topN);
                    }
                    
                    // Create scales
                    const xScale = d3.scalePoint()
                        .domain(weeks)
                        .range([0, width])
                        .padding(0.5);
                        
                    const yScale = d3.scaleLinear()
                        .domain([20, 0])  // Inverted rank (0 is best)
                        .range([height, 0]);
                        
                    // Create axes
                    const xAxis = svg.append("g")
                        .attr("transform", `translate(0,${height})`)
                        .call(d3.axisBottom(xScale)
                            .tickValues(xScale.domain().filter((d, i) => i % 4 === 0))  // Show every 4th tick
                            .tickFormat(d => {
                                const date = new Date(d);
                                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            }));
                            
                    // Rotate x-axis labels
                    xAxis.selectAll("text")
                        .style("text-anchor", "end")
                        .attr("dx", "-.8em")
                        .attr("dy", ".15em")
                        .attr("transform", "rotate(-45)");
                        
                    const yAxis = svg.append("g")
                        .call(d3.axisLeft(yScale).ticks(10));
                        
                    // Add axis labels
                    svg.append("text")
                        .attr("class", "axis-label")
                        .attr("text-anchor", "middle")
                        .attr("x", width / 2)
                        .attr("y", height + margin.bottom - 10)
                        .text("Week");
                        
                    svg.append("text")
                        .attr("class", "axis-label")
                        .attr("text-anchor", "middle")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -height / 2)
                        .attr("y", -margin.left + 20)
                        .text("Chart Rank");
                        
                    // Create line generator
                    const line = d3.line()
                        .x(d => xScale(d.week))
                        .y(d => yScale(d.rank))
                        .defined(d => d.rank !== null && d.rank !== undefined);
                        
                    // Legend group
                    const legend = svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${width + 20}, 0)`);
                        
                    // Function to update chart
                    function updateChart() {
                        // Clear previous content
                        svg.selectAll(".line-path").remove();
                        svg.selectAll(".album-dot").remove();
                        legend.selectAll("*").remove();
                        
                        const selectedArtist = d3.select("#artist-select").property("value");
                        const topN = +d3.select("#top-albums").property("value");
                        
                        let filteredData = data;
                        
                        // Filter by artist if selected
                        if (selectedArtist && selectedArtist !== 'all') {
                            filteredData = data.filter(d => d.artist === selectedArtist);
                        }
                        
                        // Get top albums
                        const topAlbums = getTopAlbums(filteredData, topN);
                        
                        // Update color domain
                        color.domain(topAlbums.map(d => d.album));
                        
                        // Group data by album
                        const albumGroups = d3.group(filteredData, d => d.album);
                        
                        // Draw lines for each top album
                        topAlbums.forEach((albumInfo, i) => {
                            const albumName = albumInfo.album;
                            const albumData = albumGroups.get(albumName) || [];
                            
                            // Sort by week
                            albumData.sort((a, b) => new Date(a.week) - new Date(b.week));
                            
                            // Draw line
                            svg.append("path")
                                .datum(albumData)
                                .attr("class", "line-path")
                                .attr("d", line)
                                .attr("stroke", color(albumName))
                                .attr("class", "line");
                                
                            // Add dots for each data point
                            svg.selectAll(`.dot-${i}`)
                                .data(albumData)
                                .enter()
                                .append("circle")
                                .attr("class", "album-dot")
                                .attr("cx", d => xScale(d.week))
                                .attr("cy", d => yScale(d.rank))
                                .attr("r", 4)
                                .attr("fill", color(albumName))
                                .on("mouseover", function(event, d) {
                                    tooltip.transition()
                                        .duration(200)
                                        .style("opacity", .9);
                                    tooltip.html(`
                                        <strong>${d.album}</strong><br/>
                                        Artist: ${d.artist}<br/>
                                        Week: ${d.week}<br/>
                                        Rank: ${d.rank + 1}<br/>
                                        Previous: ${d.previous}<br/>
                                        Peak: ${d.peak}<br/>
                                        Weeks on chart: ${d.total_weeks}
                                    `)
                                    .style("left", (event.pageX + 10) + "px")
                                    .style("top", (event.pageY - 28) + "px");
                                })
                                .on("mouseout", function() {
                                    tooltip.transition()
                                        .duration(500)
                                        .style("opacity", 0);
                                });
                                
                            // Add to legend
                            const legendItem = legend.append("g")
                                .attr("transform", `translate(0, ${i * 20})`);
                                
                            legendItem.append("rect")
                                .attr("width", 15)
                                .attr("height", 15)
                                .attr("fill", color(albumName));
                                
                            legendItem.append("text")
                                .attr("x", 20)
                                .attr("y", 12)
                                .text(`${albumName} (${albumInfo.artist})`);
                        });
                    }
                    
                    // Initial chart
                    updateChart();
                    
                    // Add event listeners to update chart when controls change
                    d3.select("#artist-select").on("change", updateChart);
                    d3.select("#top-albums").on("change", updateChart);
                    
                    // Hide loading indicator
                    d3.select("#loading").style("display", "none");
                    
                    // Set flag indicating chart is initialized
                    albumChartInitialized = true;
                    
                }).catch(error => {
                    console.error("Error loading album data:", error);
                    d3.select("#album-chart-container")
                        .append("p")
                        .text("Error loading data. Please make sure the merged album data file exists at data/Merge Data/all_albums.json");
                });
            }
        });
        // Add a new option to the visualization type dropdown
document.addEventListener('DOMContentLoaded', function() {
    // Add the new options to the visualization type dropdown
    const visualizationType = document.getElementById('visualization-type');
    if (visualizationType) {
        // Check if the options already exist
        if (!Array.from(visualizationType.options).some(opt => opt.value === 'rank-movement')) {
            // const weeklyOption = document.createElement('option');
            // weeklyOption.value = 'rank-movement';
            // weeklyOption.textContent = 'Weekly Rank Movement';
            // visualizationType.appendChild(weeklyOption);
            
            const yearlyOption = document.createElement('option');
            yearlyOption.value = 'yearly-movement';
            yearlyOption.textContent = 'Yearly Rank Movement';
            visualizationType.appendChild(yearlyOption);
        }
    }

    // Create new section for weekly rank movement chart
    const contentSection = document.querySelector('.music-analytics-content');
    if (contentSection && !document.getElementById('rank-movement-section')) {
        const rankMovementSection = document.createElement('div');
        rankMovementSection.id = 'rank-movement-section';
        rankMovementSection.className = 'visualization-section';
        rankMovementSection.style.display = 'none';  // Hidden by default
        
        rankMovementSection.innerHTML = `
            <div class="visualization-container">
                <h2>Album Rank Movement</h2>
                <div class="control-group movement-control">
                    <label for="movement-filter">Filter By:</label>
                    <select id="movement-filter">
                        <option value="all">All Movements</option>
                        <option value="improved">Improved Rank</option>
                        <option value="declined">Declined Rank</option>
                        <option value="largest">Largest Changes</option>
                    </select>
                    <label for="show-entries">Show entries:</label>
                    <input type="number" id="show-entries" min="5" max="100" value="20">
                </div>
                <div id="rank-movement-container"></div>
                <div id="movement-pagination" class="pagination-controls">
                    <button id="prev-page">« Previous</button>
                    <span id="page-info">Page 1 of 1</span>
                    <button id="next-page">Next »</button>
                </div>
            </div>
        `;
        
        contentSection.appendChild(rankMovementSection);
    }

    // Create new section for yearly rank movement chart
    if (contentSection && !document.getElementById('yearly-movement-section')) {
        const yearlyMovementSection = document.createElement('div');
        yearlyMovementSection.id = 'yearly-movement-section';
        yearlyMovementSection.className = 'visualization-section';
        yearlyMovementSection.style.display = 'none';  // Hidden by default
        
        yearlyMovementSection.innerHTML = `
            <div class="visualization-container">
                <h2>Album Yearly Rank Movement</h2>
                <div class="control-group yearly-movement-control">
                    <label for="year-comparison">Compare Years:</label>
                    <select id="year-from">
                        <option value="2017">2017</option>
                        <option value="2018">2018</option>
                        <option value="2019">2019</option>
                        <option value="2020">2020</option>
                    </select>
                    <span>to</span>
                    <select id="year-to">
                        <option value="2018">2018</option>
                        <option value="2019">2019</option>
                        <option value="2020" selected>2020</option>
                        <option value="2021">2021</option>
                    </select>
                    <label for="yearly-movement-filter">Filter By:</label>
                    <select id="yearly-movement-filter">
                        <option value="all">All Albums</option>
                        <option value="improved">Improved Rank</option>
                        <option value="declined">Declined Rank</option>
                        <option value="largest">Largest Changes</option>
                    </select>
                    <label for="yearly-show-entries">Show entries:</label>
                    <input type="number" id="yearly-show-entries" min="5" max="100" value="20">
                </div>
                <div id="yearly-movement-container"></div>
                <div id="yearly-movement-pagination" class="pagination-controls">
                    <button id="yearly-prev-page">« Previous</button>
                    <span id="yearly-page-info">Page 1 of 1</span>
                    <button id="yearly-next-page">Next »</button>
                </div>
            </div>
        `;
        
        contentSection.appendChild(yearlyMovementSection);
    }

    // Add custom styles for the new visualization
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .movement-bar.improved { fill: #4e79a7; }
        .movement-bar.declined { fill: #e15759; }
        .movement-bar.same { fill: #888888; }
        .pagination-controls {
            margin-top: 20px;
            text-align: center;
        }
        .pagination-controls button {
            padding: 5px 10px;
            margin: 0 5px;
            cursor: pointer;
        }
        .pagination-controls span {
            margin: 0 10px;
        }
        .movement-control, .yearly-movement-control {
            margin-bottom: 20px;
        }
        #show-entries, #yearly-show-entries {
            width: 60px;
        }
        #year-from, #year-to {
            width: 80px;
            margin: 0 5px;
        }
    `;
    document.head.appendChild(styleElement);

    // Modify the existing visualization type change handler
    visualizationType.addEventListener('change', function() {
        const listeningTrendsSection = document.getElementById('listening-trends-section');
        const albumTrendsSection = document.getElementById('album-trends-section');
        const rankMovementSection = document.getElementById('rank-movement-section');
        const yearlyMovementSection = document.getElementById('yearly-movement-section');
        const albumTrendsControls = document.querySelectorAll('.album-trends-control');
        
        // Hide all sections first
        listeningTrendsSection.style.display = 'none';
        albumTrendsSection.style.display = 'none';
        rankMovementSection.style.display = 'none';
        yearlyMovementSection.style.display = 'none';
        albumTrendsControls.forEach(control => control.style.display = 'none');
        
        // Show the selected section
        if (this.value === 'album-trends') {
            albumTrendsSection.style.display = 'block';
            albumTrendsControls.forEach(control => control.style.display = 'block');
            // Initialize album chart if not already initialized
            if (!window.albumChartInitialized) {
                initAlbumChart();
            }
        } else if (this.value === 'rank-movement') {
            rankMovementSection.style.display = 'block';
            // Initialize rank movement chart if not already initialized
            if (!window.rankMovementChartInitialized) {
                initRankMovementChart();
            }
        } else if (this.value === 'yearly-movement') {
            yearlyMovementSection.style.display = 'block';
            // Initialize yearly movement chart if not already initialized
            if (!window.yearlyMovementChartInitialized) {
                initYearlyMovementChart();
            }
        } else {
            listeningTrendsSection.style.display = 'block';
        }
    });

    // Global variable to track initialization
    window.yearlyMovementChartInitialized = false;
    
    // Function to initialize yearly movement chart
    window.initYearlyMovementChart = function() {
        // Chart dimensions
        const margin = {top: 50, right: 120, bottom: 50, left: 220};
        const width = 900 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;
        
        // Initialize tooltip
        let tooltip = d3.select("body").select(".yearly-movement-tooltip");
        if (tooltip.empty()) {
            tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip yearly-movement-tooltip")
                .style("opacity", 0);
        }
        
        // Create SVG
        const svg = d3.select("#yearly-movement-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Pagination state
        let currentPage = 1;
        const entriesPerPage = 20; // Default
        
        // Load data
        d3.json("../data/Merge Data/all_albums.json").then(data => {
            console.log("Data loaded for yearly movement chart:", data);
            
            // Process data - convert ranks to numbers
            data.forEach(d => {
                d.rank = +d.rank;
                d.previous = +d.previous;
                d.peak = +d.peak;
                d.total_weeks = +d.total_weeks;
                
                // Extract year from week data
                const weekDate = new Date(d.week);
                d.year = weekDate.getFullYear();
            });
            
            // Get unique years from the data
            const years = [...new Set(data.map(d => d.year))].sort();
            
            // Populate year dropdowns
            const yearFromSelect = d3.select("#year-from");
            const yearToSelect = d3.select("#year-to");
            
            // Clear existing options
            yearFromSelect.selectAll("option").remove();
            yearToSelect.selectAll("option").remove();
            
            // Add year options
            years.forEach((year, i) => {
                yearFromSelect.append("option")
                    .attr("value", year)
                    .text(year)
                    .property("selected", i === 0); // Select first year by default
                
                yearToSelect.append("option")
                    .attr("value", year)
                    .text(year)
                    .property("selected", i === years.length - 1); // Select last year by default
            });
            
            // Function to calculate average rank for each album in a given year
            function calculateYearlyRanks(data, year) {
                // Filter data for the given year
                const yearData = data.filter(d => d.year === year);
                
                // Group by album and artist
                const albumGroups = d3.group(yearData, d => d.album + '|' + d.artist);
                
                // Calculate average rank for each album
                const yearlyRanks = Array.from(albumGroups, ([key, entries]) => {
                    const [album, artist] = key.split('|');
                    return {
                        album: album,
                        artist: artist,
                        year: year,
                        avgRank: d3.mean(entries, d => d.rank),
                        minRank: d3.min(entries, d => d.rank), // Best position
                        maxRank: d3.max(entries, d => d.rank), // Worst position
                        weekCount: entries.length, // Number of weeks on chart in that year
                        firstWeek: d3.min(entries, d => d.week),
                        lastWeek: d3.max(entries, d => d.week)
                    };
                });
                
                return yearlyRanks;
            }
            
            // Function to calculate movement between two years
            function calculateYearlyMovement(fromYear, toYear) {
                const fromYearRanks = calculateYearlyRanks(data, fromYear);
                const toYearRanks = calculateYearlyRanks(data, toYear);
                
                // Find albums that appear in both years
                const movementData = [];
                
                fromYearRanks.forEach(fromAlbum => {
                    const matchingToAlbum = toYearRanks.find(toAlbum => 
                        toAlbum.album === fromAlbum.album && toAlbum.artist === fromAlbum.artist
                    );
                    
                    if (matchingToAlbum) {
                        movementData.push({
                            album: fromAlbum.album,
                            artist: fromAlbum.artist,
                            fromYear: fromYear,
                            toYear: toYear,
                            fromRank: fromAlbum.avgRank,
                            toRank: matchingToAlbum.avgRank,
                            movement: fromAlbum.avgRank - matchingToAlbum.avgRank, // Positive = improved
                            fromWeeks: fromAlbum.weekCount,
                            toWeeks: matchingToAlbum.weekCount
                        });
                    }
                });
                
                return movementData;
            }
            
            // Function to update chart
            function updateChart() {
                // Clear previous content
                svg.selectAll("*").remove();
                
                // Get filter values
                const selectedArtist = d3.select("#artist-select").property("value");
                const yearFrom = +d3.select("#year-from").property("value");
                const yearTo = +d3.select("#year-to").property("value");
                const movementFilter = d3.select("#yearly-movement-filter").property("value");
                const showEntries = +d3.select("#yearly-show-entries").property("value");
                
                // Ensure years are in the right order
                if (yearFrom >= yearTo) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .text("Please select different years (From year must be earlier than To year)");
                    return;
                }
                
                // Calculate movement data between the two years
                let movementData = calculateYearlyMovement(yearFrom, yearTo);
                
                // Apply artist filter
                if (selectedArtist && selectedArtist !== 'all') {
                    movementData = movementData.filter(d => d.artist === selectedArtist);
                }
                
                // Apply movement filter
                if (movementFilter === 'improved') {
                    movementData = movementData.filter(d => d.movement > 0);
                } else if (movementFilter === 'declined') {
                    movementData = movementData.filter(d => d.movement < 0);
                } else if (movementFilter === 'largest') {
                    // Sort by absolute movement value and take top entries
                    movementData.sort((a, b) => Math.abs(b.movement) - Math.abs(a.movement));
                }
                
                // Sort data by movement magnitude
                movementData.sort((a, b) => Math.abs(b.movement) - Math.abs(a.movement));
                
                // Update pagination
                const totalPages = Math.ceil(movementData.length / showEntries);
                if (currentPage > totalPages) {
                    currentPage = Math.max(1, totalPages);
                }
                
                // Update page info
                d3.select("#yearly-page-info").text(`Page ${currentPage} of ${totalPages} (${movementData.length} entries)`);
                
                // Enable/disable pagination buttons
                d3.select("#yearly-prev-page").property("disabled", currentPage <= 1);
                d3.select("#yearly-next-page").property("disabled", currentPage >= totalPages);
                
                // Get current page data
                const startIndex = (currentPage - 1) * showEntries;
                const endIndex = Math.min(startIndex + showEntries, movementData.length);
                const pageData = movementData.slice(startIndex, endIndex);
                
                // No data message
                if (pageData.length === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .text("No chart movement data available for the selected years and filters");
                    return;
                }
                
                // Calculate maximum movement for scale
                const maxMovement = d3.max(pageData, d => Math.abs(d.movement));
                
                // Create scales
                const albumScale = d3.scaleBand()
                    .domain(pageData.map(d => `${d.album} (${d.artist})`))
                    .range([0, height])
                    .padding(0.2);
                
                const movementScale = d3.scaleLinear()
                    .domain([-maxMovement - 1, maxMovement + 1])
                    .range([0, width]);
                
                // Add centerline
                svg.append("line")
                    .attr("x1", movementScale(0))
                    .attr("y1", 0)
                    .attr("x2", movementScale(0))
                    .attr("y2", height)
                    .attr("stroke", "#888")
                    .attr("stroke-width", 1)
                    .attr("stroke-dasharray", "4");
                
                // Create axes
                const xAxis = svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(movementScale).ticks(10));
                
                const yAxis = svg.append("g")
                    .call(d3.axisLeft(albumScale)
                        .tickFormat(d => {
                            // Only show first part to save space
                            return d.length > 30 ? d.substring(0, 30) + '...' : d;
                        }));
                
                // Add axis labels
                svg.append("text")
                    .attr("class", "axis-label")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", height + margin.bottom - 10)
                    .text("Average Rank Change (+ = Improved, - = Declined)");
                
                // Add chart title
                svg.append("text")
                    .attr("class", "chart-title")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", -30)
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .text(`Album Chart Performance: ${yearFrom} vs ${yearTo}`);
                
                // Draw bars
                svg.selectAll(".movement-bar")
                    .data(pageData)
                    .enter()
                    .append("rect")
                    .attr("class", d => `movement-bar ${d.movement > 0 ? 'improved' : d.movement < 0 ? 'declined' : 'same'}`)
                    .attr("y", d => albumScale(`${d.album} (${d.artist})`))
                    .attr("x", d => d.movement < 0 ? movementScale(0) : movementScale(0))
                    .attr("width", d => Math.abs(movementScale(d.movement) - movementScale(0)))
                    .attr("height", albumScale.bandwidth())
                    .attr("transform", d => {
                        // For negative movement, shift the bar to the left of centerline
                        return d.movement < 0 ? `translate(${movementScale(d.movement) - movementScale(0)}, 0)` : "";
                    })
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        tooltip.html(`
                            <strong>${d.album}</strong><br/>
                            Artist: ${d.artist}<br/>
                            ${yearFrom} Avg. Rank: ${d.fromRank.toFixed(1)}<br/>
                            ${yearTo} Avg. Rank: ${d.toRank.toFixed(1)}<br/>
                            Change: ${d.movement > 0 ? "+" + d.movement.toFixed(1) : d.movement.toFixed(1)}<br/>
                            ${d.movement > 0 ? "Improved" : d.movement < 0 ? "Declined" : "No Change"}<br/>
                            Weeks in ${yearFrom}: ${d.fromWeeks}<br/>
                            Weeks in ${yearTo}: ${d.toWeeks}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                // Add value labels
                svg.selectAll(".value-label")
                    .data(pageData)
                    .enter()
                    .append("text")
                    .attr("class", "value-label")
                    .attr("x", d => {
                        const barEnd = d.movement < 0 ? 
                            movementScale(d.movement) : 
                            movementScale(d.movement);
                        return d.movement < 0 ? barEnd - 20 : barEnd + 5;
                    })
                    .attr("y", d => albumScale(`${d.album} (${d.artist})`) + albumScale.bandwidth() / 2)
                    .attr("dy", ".35em")
                    .attr("text-anchor", d => d.movement < 0 ? "end" : "start")
                    .text(d => (d.movement > 0 ? "+" : "") + d.movement.toFixed(1))
                    .attr("fill", d => d.movement === 0 ? "#333" : "white");
            }
            
            // Initialize chart
            updateChart();
            
            // Add event listeners
            d3.select("#artist-select").on("change", function() {
                currentPage = 1; // Reset to first page on filter change
                updateChart();
            });
            
            d3.select("#yearly-movement-filter").on("change", function() {
                currentPage = 1; // Reset to first page on filter change
                updateChart();
            });
            
            d3.select("#yearly-show-entries").on("change", function() {
                currentPage = 1; // Reset to first page when changing entries per page
                updateChart();
            });
            
            d3.select("#year-from").on("change", function() {
                currentPage = 1; // Reset to first page on year change
                updateChart();
            });
            
            d3.select("#year-to").on("change", function() {
                currentPage = 1; // Reset to first page on year change
                updateChart();
            });
            
            // Add pagination events
            d3.select("#yearly-prev-page").on("click", function() {
                if (currentPage > 1) {
                    currentPage--;
                    updateChart();
                }
            });
            
            d3.select("#yearly-next-page").on("click", function() {
                const showEntries = +d3.select("#yearly-show-entries").property("value");
                const yearFrom = +d3.select("#year-from").property("value");
                const yearTo = +d3.select("#year-to").property("value");
                const movementFilter = d3.select("#yearly-movement-filter").property("value");
                const selectedArtist = d3.select("#artist-select").property("value");
                
                // Calculate movement data
                let movementData = calculateYearlyMovement(yearFrom, yearTo);
                
                // Apply filters
                if (selectedArtist && selectedArtist !== 'all') {
                    movementData = movementData.filter(d => d.artist === selectedArtist);
                }
                
                if (movementFilter === 'improved') {
                    movementData = movementData.filter(d => d.movement > 0);
                } else if (movementFilter === 'declined') {
                    movementData = movementData.filter(d => d.movement < 0);
                } else if (movementFilter === 'largest') {
                    movementData.sort((a, b) => Math.abs(b.movement) - Math.abs(a.movement));
                }
                
                const totalPages = Math.ceil(movementData.length / showEntries);
                
                if (currentPage < totalPages) {
                    currentPage++;
                    updateChart();
                }
            });
            
            // Set flag indicating chart is initialized
            window.yearlyMovementChartInitialized = true;
            
        }).catch(error => {
            console.error("Error loading album data for yearly movement chart:", error);
            d3.select("#yearly-movement-container")
                .append("p")
                .text("Error loading data. Please make sure the merged album data file exists at data/Merge Data/all_albums.json");
        });
    }
});
// Add this to your existing script tag or create a new one

document.addEventListener('DOMContentLoaded', function() {
    // Add the new option to the visualization type dropdown
    const visualizationType = document.getElementById('visualization-type');
    if (visualizationType) {
        // Check if the option already exists
        if (!Array.from(visualizationType.options).some(opt => opt.value === 'top-artists-streams')) {
            const artistStreamsOption = document.createElement('option');
            artistStreamsOption.value = 'top-artists-streams';
            artistStreamsOption.textContent = 'Top Artists by Streams';
            visualizationType.appendChild(artistStreamsOption);
        }
    }

    // Create new section for top artists streams visualization
    const contentSection = document.querySelector('.music-analytics-content');
    if (contentSection && !document.getElementById('top-artists-streams-section')) {
        const topArtistsSection = document.createElement('div');
        topArtistsSection.id = 'top-artists-streams-section';
        topArtistsSection.className = 'visualization-section';
        topArtistsSection.style.display = 'none';  // Hidden by default
        
        topArtistsSection.innerHTML = `
            <div class="visualization-container">
                <h2>Top 5 Artists by Total Streams</h2>
                <div class="control-group artist-streams-control">
                    <label for="artists-time-range">Time Range:</label>
                    <select id="artists-time-range">
                        <option value="12">12 weeks</option>
                        <option value="24">24 weeks</option>
                        <option value="52">52 weeks</option>
                    </select>
                    <label for="start-week">Starting Week:</label>
                    <select id="start-week"></select>
                    <label for="top-artists-count">Top Artists:</label>
                    <input type="number" id="top-artists-count" min="3" max="10" value="5">
                </div>
                <div id="artists-streams-container"></div>
            </div>
        `;
        
        contentSection.appendChild(topArtistsSection);
    }

    // Add styles for the new visualization
    const styleElement = document.createElement('style');
    styleElement.textContent += `
        .artist-streams-control {
            margin-bottom: 20px;
        }
        #top-artists-count {
            width: 60px;
        }
        #artists-time-range, #start-week {
            width: 100px;
            margin: 0 5px;
        }
        .artist-line {
            fill: none;
            stroke-width: 2.5;
        }
        .artist-dot {
            cursor: pointer;
        }
    `;
    document.head.appendChild(styleElement);

    // Modify the existing visualization type change handler
    const originalTypeChangeHandler = visualizationType.onchange;
    visualizationType.addEventListener('change', function() {
        // Call the original handler if it exists
        if (typeof originalTypeChangeHandler === 'function') {
            originalTypeChangeHandler.call(this);
        }
        
        const topArtistsStreamsSection = document.getElementById('top-artists-streams-section');
        
        // Handle our new visualization type
        if (this.value === 'top-artists-streams') {
            // Hide all other sections (this assumes your code already does this)
            document.querySelectorAll('.visualization-section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Show our section
            topArtistsStreamsSection.style.display = 'block';
            
            // Initialize the chart if needed
            if (!window.topArtistsStreamsInitialized) {
                initTopArtistsStreamsChart();
            }
        }
    });

    // Global variable to track initialization
    window.topArtistsStreamsInitialized = false;
    
    // Function to initialize top artists streams chart
    window.initTopArtistsStreamsChart = function() {
        // Chart dimensions
        const margin = {top: 50, right: 160, bottom: 100, left: 80};
        const width = 900 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;
        
        // Initialize tooltip
        let tooltip = d3.select("body").select(".artists-streams-tooltip");
        if (tooltip.empty()) {
            tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip artists-streams-tooltip")
                .style("opacity", 0);
        }
        
        // Create SVG
        const svg = d3.select("#artists-streams-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
            
        // Color scale - use a predefined color scheme
        const colors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", 
                       "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
        const colorScale = d3.scaleOrdinal(colors);
        
        // Function to parse the stream count
        function parseStreams(s) {
            if (typeof s === 'string') {
                return parseInt(s.replace(/,/g, ""));
            }
            return s;
        }
            
        // Load song data
        Promise.all([
            d3.json("../data/Merge Data/all_songs.json"),
            // You might want to add more data sources if needed
        ]).then(([songsData]) => {
            console.log("Songs data loaded:", songsData);
                
            // Process data
            // Extract unique weeks from the data
            const weeks = [...new Set(songsData.map(d => d.week))].sort();
            
            // Populate the start week dropdown
            const startWeekSelect = d3.select("#start-week");
            startWeekSelect.selectAll("option").remove();
            
            weeks.forEach(week => {
                startWeekSelect.append("option")
                    .attr("value", week)
                    .text(week);
            });
            
            // Set a default start week
            if (weeks.includes("2018-06-07")) {
                startWeekSelect.property("value", "2018-06-07");
            } else if (weeks.length > 0) {
                startWeekSelect.property("value", weeks[0]);
            }
                
            // Function to update chart
            function updateChart() {
                // Clear previous content
                svg.selectAll("*").remove();
                
                // Get selected parameters
                const startWeek = startWeekSelect.property("value");
                const numWeeks = +d3.select("#artists-time-range").property("value");
                const topCount = +d3.select("#top-artists-count").property("value");
                
                // Find the start week index and calculate the target weeks
                const startIndex = weeks.indexOf(startWeek);
                if (startIndex === -1 || startIndex + numWeeks > weeks.length) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .text("Invalid date range selected");
                    return;
                }
                
                const targetWeeks = weeks.slice(startIndex, startIndex + numWeeks);
                
                // Filter data for the target weeks
                const filteredData = songsData.filter(d => targetWeeks.includes(d.week));
                
                // Calculate artist streams
                const artistStreamsTotal = {};
                const artistWeeklyStreams = {};
                
                filteredData.forEach(entry => {
                    const streams = parseStreams(entry.streams);
                    
                    // Handle both single artist and multiple artists formats
                    let artists = [];
                    if (entry.artist) {
                        // Split on commas and feat. to handle multiple artists
                        artists = entry.artist.split(/,|feat\.|featuring/).map(a => a.trim());
                    } else if (Array.isArray(entry.artists)) {
                        artists = entry.artists;
                    }
                    
                    artists.forEach(artist => {
                        // Skip empty artists
                        if (!artist) return;
                        
                        // Initialize if needed
                        if (!artistStreamsTotal[artist]) {
                            artistStreamsTotal[artist] = 0;
                            artistWeeklyStreams[artist] = {};
                        }
                        
                        // Add to total streams
                        artistStreamsTotal[artist] += streams;
                        
                        // Add to weekly streams
                        if (!artistWeeklyStreams[artist][entry.week]) {
                            artistWeeklyStreams[artist][entry.week] = 0;
                        }
                        artistWeeklyStreams[artist][entry.week] += streams;
                    });
                });
                
                // Sort artists by total streams and get the top ones
                const topArtists = Object.entries(artistStreamsTotal)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, topCount)
                    .map(([artist]) => artist);
                
                // Prepare the data for plotting
                const plotData = [];
                
                topArtists.forEach(artist => {
                    targetWeeks.forEach(week => {
                        plotData.push({
                            artist: artist,
                            week: week,
                            streams: artistWeeklyStreams[artist][week] || 0
                        });
                    });
                });
                
                // Create scales
                const xScale = d3.scaleBand()
                    .domain(targetWeeks)
                    .range([0, width])
                    .padding(0.1);
                
                const maxStreams = d3.max(plotData, d => d.streams);
                const yScale = d3.scaleLinear()
                    .domain([0, maxStreams * 1.1]) // Add 10% padding
                    .range([height, 0]);
                
                // Create axes
                const xAxis = svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale)
                        .tickValues(xScale.domain().filter((d, i) => i % Math.ceil(targetWeeks.length / 12) === 0))
                        .tickFormat(d => {
                            const date = new Date(d);
                            return date.toLocaleDateString('en-US', { 
                                year: '2-digit', 
                                month: '2-digit', 
                                day: '2-digit' 
                            });
                        }));
                
                // Rotate x-axis labels
                xAxis.selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", "rotate(-45)");
                
                const yAxis = svg.append("g")
                    .call(d3.axisLeft(yScale)
                        .tickFormat(d => {
                            if (d >= 1000000) {
                                return (d / 1000000).toFixed(0) + 'M';
                            } else if (d >= 1000) {
                                return (d / 1000).toFixed(0) + 'K';
                            }
                            return d;
                        }));
                
                // Add axis labels
                svg.append("text")
                    .attr("class", "axis-label")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", height + margin.bottom - 10)
                    .text("Week");
                
                svg.append("text")
                    .attr("class", "axis-label")
                    .attr("text-anchor", "middle")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -height / 2)
                    .attr("y", -margin.left + 20)
                    .text("Streams");
                
                // Add chart title
                svg.append("text")
                    .attr("class", "chart-title")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", -30)
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .text(`Top ${topArtists.length} Artists by Total Streams (${numWeeks}-week period starting ${startWeek})`);
                
                // Create line generator
                const line = d3.line()
                    .x(d => xScale(d.week) + xScale.bandwidth() / 2)
                    .y(d => yScale(d.streams))
                    .curve(d3.curveMonotoneX);
                
                // Group data by artist
                const artistGroups = d3.group(plotData, d => d.artist);
                
                // Draw lines for each artist
                topArtists.forEach((artist, i) => {
                    const artistData = Array.from(artistGroups.get(artist) || []);
                    
                    // Sort data by week
                    artistData.sort((a, b) => new Date(a.week) - new Date(b.week));
                    
                    // Draw line
                    svg.append("path")
                        .datum(artistData)
                        .attr("class", "artist-line")
                        .attr("d", line)
                        .attr("stroke", colorScale(artist))
                        .attr("stroke-width", 2);
                    
                    // Add dots for each data point
                    svg.selectAll(`.dot-${i}`)
                        .data(artistData)
                        .enter()
                        .append("circle")
                        .attr("class", "artist-dot")
                        .attr("cx", d => xScale(d.week) + xScale.bandwidth() / 2)
                        .attr("cy", d => yScale(d.streams))
                        .attr("r", 5)
                        .attr("fill", colorScale(artist))
                        .on("mouseover", function(event, d) {
                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .9);
                            tooltip.html(`
                                <strong>${d.artist}</strong><br/>
                                Week: ${d.week}<br/>
                                Streams: ${d.streams.toLocaleString()}
                            `)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function() {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        });
                });
                
                // Add legend
                const legend = svg.append("g")
                    .attr("class", "legend")
                    .attr("transform", `translate(${width + 20}, 0)`);
                
                topArtists.forEach((artist, i) => {
                    const legendItem = legend.append("g")
                        .attr("transform", `translate(0, ${i * 20})`);
                    
                    legendItem.append("rect")
                        .attr("width", 15)
                        .attr("height", 15)
                        .attr("fill", colorScale(artist));
                    
                    legendItem.append("text")
                        .attr("x", 20)
                        .attr("y", 12)
                        .text(artist);
                });
            }
            
            // Initial chart
            updateChart();
            
            // Add event listeners
            d3.select("#artists-time-range").on("change", updateChart);
            d3.select("#start-week").on("change", updateChart);
            d3.select("#top-artists-count").on("change", updateChart);
            
            // Set flag indicating chart is initialized
            window.topArtistsStreamsInitialized = true;
            
        }).catch(error => {
            console.error("Error loading data for artists streams chart:", error);
            d3.select("#artists-streams-container")
                .append("p")
                .text("Error loading data. Please make sure the all_songs.json file exists at data/Merge Data/all_songs.json");
        });
    };
});
// First, add the new option to the visualization type dropdown
document.addEventListener('DOMContentLoaded', function() {
    // Add the heatmap option to the visualization type dropdown
    const visualizationType = document.getElementById('visualization-type');
    if (visualizationType) {
        if (!Array.from(visualizationType.options).some(opt => opt.value === 'artist-heatmap')) {
            const heatmapOption = document.createElement('option');
            heatmapOption.value = 'artist-heatmap';
            heatmapOption.textContent = 'Artist Weekly Rank Heatmap';
            visualizationType.appendChild(heatmapOption);
        }
    }

    // Create new section for the artist heatmap
    const contentSection = document.querySelector('.music-analytics-content');
    if (contentSection && !document.getElementById('artist-heatmap-section')) {
        const heatmapSection = document.createElement('div');
        heatmapSection.id = 'artist-heatmap-section';
        heatmapSection.className = 'visualization-section';
        heatmapSection.style.display = 'none';  // Hidden by default
        
        heatmapSection.innerHTML = `
            <div class="visualization-container">
                <h2>Weekly Ranks Heatmap of Top Artists</h2>
                <div class="control-group heatmap-control">
                    <label for="top-artists">Top Artists:</label>
                    <input type="number" id="top-artists" min="3" max="10" value="5">
                    <label for="min-weeks">Min Weeks on Chart:</label>
                    <input type="number" id="min-weeks" min="1" max="20" value="4">
                    <label for="heatmap-time-range">Time Range:</label>
                    <select id="heatmap-time-range">
                        <option value="all">All Time</option>
                        <option value="last-year">Last Year</option>
                        <option value="last-6-months">Last 6 Months</option>
                        <option value="last-3-months">Last 3 Months</option>
                    </select>
                </div>
                <div id="artist-heatmap-container"></div>
            </div>
        `;
        
        contentSection.appendChild(heatmapSection);
    }

    // Add custom styles for the heatmap visualization
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        .heatmap-control {
            margin-bottom: 20px;
        }
        #top-artists, #min-weeks {
            width: 60px;
            margin-right: 15px;
        }
        #heatmap-time-range {
            width: 120px;
        }
        .heatmap-cell {
            stroke: white;
            stroke-width: 1px;
        }
        .heatmap-axis text {
            font-size: 12px;
        }
        .heatmap-label {
            font-size: 12px;
            font-weight: bold;
        }
    `;
    document.head.appendChild(styleElement);

    // Modify the existing visualization type change handler to include our new section
    visualizationType.addEventListener('change', function() {
        const listeningTrendsSection = document.getElementById('listening-trends-section');
        const albumTrendsSection = document.getElementById('album-trends-section');
        const rankMovementSection = document.getElementById('rank-movement-section');
        const yearlyMovementSection = document.getElementById('yearly-movement-section');
        const artistHeatmapSection = document.getElementById('artist-heatmap-section');
        const albumTrendsControls = document.querySelectorAll('.album-trends-control');
        
        // Hide all sections first
        listeningTrendsSection.style.display = 'none';
        albumTrendsSection.style.display = 'none';
        rankMovementSection.style.display = 'none';
        yearlyMovementSection.style.display = 'none';
        artistHeatmapSection.style.display = 'none';
        albumTrendsControls.forEach(control => control.style.display = 'none');
        
        // Show the selected section
        if (this.value === 'album-trends') {
            albumTrendsSection.style.display = 'block';
            albumTrendsControls.forEach(control => control.style.display = 'block');
            // Initialize album chart if not already initialized
            if (!window.albumChartInitialized) {
                initAlbumChart();
            }
        } else if (this.value === 'rank-movement') {
            rankMovementSection.style.display = 'block';
            // Initialize rank movement chart if not already initialized
            if (!window.rankMovementChartInitialized) {
                initRankMovementChart();
            }
        } else if (this.value === 'yearly-movement') {
            yearlyMovementSection.style.display = 'block';
            // Initialize yearly movement chart if not already initialized
            if (!window.yearlyMovementChartInitialized) {
                initYearlyMovementChart();
            }
        } else if (this.value === 'artist-heatmap') {
            artistHeatmapSection.style.display = 'block';
            // Initialize artist heatmap if not already initialized
            if (!window.artistHeatmapInitialized) {
                initArtistHeatmap();
            }
        } else {
            listeningTrendsSection.style.display = 'block';
        }
    });

    // Global variable to track initialization
    window.artistHeatmapInitialized = false;
    
    // Function to initialize artist heatmap
    window.initArtistHeatmap = function() {
        // Chart dimensions
        const margin = {top: 50, right: 100, bottom: 100, left: 120};
        const width = 900 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;
        
        // Initialize tooltip
        let tooltip = d3.select("body").select(".artist-heatmap-tooltip");
        if (tooltip.empty()) {
            tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip artist-heatmap-tooltip")
                .style("opacity", 0);
        }
        
        // Create SVG
        const svg = d3.select("#artist-heatmap-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Load data
        d3.json("../data/Merge Data/all_artists.json").then(data => {
            console.log("Data loaded for artist heatmap:", data);
            
            // Process data
            data.forEach(d => {
                d.rank = +d.rank;  // Convert rank to number
                d.peak = +d.peak;
                d.total_weeks = +d.total_weeks;
                // Try to convert previous if it's not a dash or undefined
                if (d.previous && d.previous !== "—" && d.previous !== "\u2014") {
                    d.previous = +d.previous;
                }
            });
            
            // Function to update heatmap
            function updateHeatmap() {
                // Clear previous content
                svg.selectAll("*").remove();
                
                // Get filter values
                const topArtistsCount = +d3.select("#top-artists").property("value");
                const minWeeks = +d3.select("#min-weeks").property("value");
                const timeRange = d3.select("#heatmap-time-range").property("value");
                
                // Filter data by time range
                let filteredData = [...data];
                if (timeRange !== 'all') {
                    const currentDate = new Date();
                    let cutoffDate;
                    
                    if (timeRange === 'last-year') {
                        cutoffDate = new Date(currentDate);
                        cutoffDate.setFullYear(currentDate.getFullYear() - 1);
                    } else if (timeRange === 'last-6-months') {
                        cutoffDate = new Date(currentDate);
                        cutoffDate.setMonth(currentDate.getMonth() - 6);
                    } else if (timeRange === 'last-3-months') {
                        cutoffDate = new Date(currentDate);
                        cutoffDate.setMonth(currentDate.getMonth() - 3);
                    }
                    
                    filteredData = filteredData.filter(d => new Date(d.week) >= cutoffDate);
                }
                
                // Get all unique weeks
                const weeks = [...new Set(filteredData.map(d => d.week))].sort();
                
                // Calculate weighted scores for each artist (for ranking purpose)
                const artistWeeks = d3.group(filteredData, d => d.artist);
                const weightedScores = new Map();
                
                artistWeeks.forEach((artistData, artist) => {
                    // Only consider artists who appear in at least minWeeks weeks
                    if (artistData.length >= minWeeks) {
                        // Calculate inverse rank sum (lower rank = better)
                        // Formula: Sum of (21 - rank) for each week the artist appears
                        const weightedScore = d3.sum(artistData, d => 21 - d.rank);
                        weightedScores.set(artist, weightedScore);
                    }
                });
                
                // No data message if no artists meet criteria
                if (weightedScores.size === 0) {
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .text("No artists meet the minimum weeks criteria with the current filters");
                    return;
                }
                
                // Get top artists based on weighted scores
                const topArtists = Array.from(weightedScores.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, topArtistsCount)
                    .map(d => d[0]);
                
                // Create rank matrix
                const rankMatrix = [];
                
                // For each artist, get their rank for each week
                topArtists.forEach(artist => {
                    const artistData = filteredData.filter(d => d.artist === artist);
                    const artistRanks = d3.group(artistData, d => d.week);
                    
                    weeks.forEach(week => {
                        const weekData = artistRanks.get(week);
                        if (weekData && weekData.length > 0) {
                            rankMatrix.push({
                                artist: artist,
                                week: week,
                                rank: weekData[0].rank
                            });
                        } else {
                            // No data for this week - add null rank
                            rankMatrix.push({
                                artist: artist,
                                week: week,
                                rank: null
                            });
                        }
                    });
                });
                
                // Create scales
                const xScale = d3.scaleBand()
                    .domain(weeks)
                    .range([0, width])
                    .padding(0.05);
                
                const yScale = d3.scaleBand()
                    .domain(topArtists)
                    .range([0, height])
                    .padding(0.05);
                
                // Color scale - viridis_r for ranks (lower rank = better = lighter color)
                const colorScale = d3.scaleSequential(d3.interpolateViridis)
                    .domain([20, 1])  // Invert domain for reverse colormap (lower rank = better)
                
                // Create x-axis with rotated labels
                const xAxis = svg.append("g")
                    .attr("class", "heatmap-axis")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale)
                        .tickValues(xScale.domain().filter((d, i) => i % Math.ceil(weeks.length / 12) === 0))
                        .tickFormat(d => {
                            const date = new Date(d);
                            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                        }));
                
                // Rotate x-axis labels
                xAxis.selectAll("text")
                    .style("text-anchor", "end")
                    .attr("dx", "-.8em")
                    .attr("dy", ".15em")
                    .attr("transform", "rotate(-45)");
                
                // Create y-axis
                const yAxis = svg.append("g")
                    .attr("class", "heatmap-axis")
                    .call(d3.axisLeft(yScale));
                
                // Add title
                svg.append("text")
                    .attr("class", "chart-title")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", -20)
                    .attr("font-size", "16px")
                    .attr("font-weight", "bold")
                    .text("Weekly Ranks Heatmap of Top Artists");
                
                // Add x-axis label
                svg.append("text")
                    .attr("class", "heatmap-label")
                    .attr("text-anchor", "middle")
                    .attr("x", width / 2)
                    .attr("y", height + margin.bottom - 10)
                    .text("Week");
                
                // Add y-axis label
                svg.append("text")
                    .attr("class", "heatmap-label")
                    .attr("text-anchor", "middle")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -height / 2)
                    .attr("y", -margin.left + 30)
                    .text("Artist");
                
                // Draw heatmap cells
                svg.selectAll(".heatmap-cell")
                    .data(rankMatrix)
                    .enter()
                    .append("rect")
                    .attr("class", "heatmap-cell")
                    .attr("x", d => xScale(d.week))
                    .attr("y", d => yScale(d.artist))
                    .attr("width", xScale.bandwidth())
                    .attr("height", yScale.bandwidth())
                    .attr("fill", d => d.rank ? colorScale(d.rank) : "#eee")  // Grey for missing data
                    .on("mouseover", function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", .9);
                        
                        const dateFormatted = new Date(d.week).toLocaleDateString('en-US', 
                            { month: 'long', day: 'numeric', year: 'numeric' });
                        
                        tooltip.html(`
                            <strong>${d.artist}</strong><br/>
                            Week: ${dateFormatted}<br/>
                            ${d.rank ? `Rank: ${d.rank}` : "Not ranked this week"}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });
                
                // Add rank text to cells
                svg.selectAll(".rank-text")
                    .data(rankMatrix)
                    .enter()
                    .append("text")
                    .attr("class", "rank-text")
                    .attr("x", d => xScale(d.week) + xScale.bandwidth() / 2)
                    .attr("y", d => yScale(d.artist) + yScale.bandwidth() / 2)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "central")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .style("fill", d => d.rank && d.rank > 10 ? "white" : "black")  // White text for darker cells
                    .text(d => d.rank ? d.rank : "");
                
                // Add color scale legend
                const legendWidth = 20;
                const legendHeight = height;
                
                // Create gradient for legend
                const defs = svg.append("defs");
                
                const gradient = defs.append("linearGradient")
                    .attr("id", "heatmap-gradient")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "0%")
                    .attr("y2", "100%");
                
                // Add color stops
                const stops = [
                    { offset: "0%", color: colorScale(1) },  // Best rank (1)
                    { offset: "20%", color: colorScale(5) },
                    { offset: "40%", color: colorScale(9) },
                    { offset: "60%", color: colorScale(13) },
                    { offset: "80%", color: colorScale(17) },
                    { offset: "100%", color: colorScale(20) }  // Worst rank (20)
                ];
                
                stops.forEach(stop => {
                    gradient.append("stop")
                        .attr("offset", stop.offset)
                        .attr("stop-color", stop.color);
                });
                
                // Create legend rectangle
                svg.append("rect")
                    .attr("x", width + 20)
                    .attr("y", 0)
                    .attr("width", legendWidth)
                    .attr("height", legendHeight)
                    .style("fill", "url(#heatmap-gradient)");
                
                // Add legend axis
                const legendScale = d3.scaleLinear()
                    .domain([1, 20])  // Rank range
                    .range([0, legendHeight]);
                
                const legendAxis = d3.axisRight(legendScale)
                    .tickValues([1, 5, 10, 15, 20])
                    .tickFormat(d => d);
                
                svg.append("g")
                    .attr("transform", `translate(${width + 20 + legendWidth}, 0)`)
                    .call(legendAxis);
                
                // Add legend title
                svg.append("text")
                    .attr("text-anchor", "middle")
                    .attr("transform", "rotate(90)")
                    .attr("x", legendHeight / 2)
                    .attr("y", -(width + 70))
                    .attr("font-size", "12px")
                    .attr("font-weight", "bold")
                    .text("Rank");
            }
            
            // Initialize heatmap
            updateHeatmap();
            
            // Add event listeners
            d3.select("#top-artists").on("change", updateHeatmap);
            d3.select("#min-weeks").on("change", updateHeatmap);
            d3.select("#heatmap-time-range").on("change", updateHeatmap);
            
            // Set flag indicating chart is initialized
            window.artistHeatmapInitialized = true;
            
        }).catch(error => {
            console.error("Error loading artist data for heatmap:", error);
            d3.select("#artist-heatmap-container")
                .append("p")
                .text("Error loading data. Please make sure the merged artist data file exists at data/Merge Data/all_artists.json");
        });
    }
});
    </script>
    

    
</body>
</html>